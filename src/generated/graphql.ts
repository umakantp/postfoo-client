/* IMP: This file is auto-generated by npm run generate, don't change manually */
/* eslint-disable */
import { useMutation, useQuery, UseMutationOptions, UseQueryOptions } from '@tanstack/react-query';
import { reactQueryFetcher } from 'src/utils/react-query-fetcher';
export type Maybe<T> = T | undefined;
export type InputMaybe<T> = T | undefined;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  BigInt: { input: number; output: number; }
  Date: { input: string; output: string; }
  DateTime: { input: string; output: string; }
  EmailAddress: { input: string; output: string; }
  JWT: { input: string; output: string; }
  PhoneNumber: { input: string; output: string; }
  URL: { input: string; output: string; }
  Void: { input: void; output: void; }
};

export type Code = Node & {
  /**  The OTP code that was sent to the user  */
  code: Scalars['ID']['output'];
  createdAt: Scalars['DateTime']['output'];
  /**  When the code expires if set  */
  expireAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
  /**  The user that this code is for  */
  user: User;
};

export type CreateFundInput = {
  category?: InputMaybe<FundCategory>;
  description?: InputMaybe<Scalars['String']['input']>;
  lastNav: Scalars['Float']['input'];
  name: Scalars['String']['input'];
  plan: FundPlan;
  symbol1?: InputMaybe<Scalars['String']['input']>;
  symbol2?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<FundType>;
};

export type CreatePortfolioFundInput = {
  cost: Scalars['Float']['input'];
  fundId: Scalars['ID']['input'];
  portfolioId: Scalars['ID']['input'];
  units: Scalars['Float']['input'];
};

export type CreatePortfolioInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

export type CreatePortfolioStockInput = {
  cost: Scalars['Float']['input'];
  portfolioId: Scalars['ID']['input'];
  stockId: Scalars['ID']['input'];
  units: Scalars['Float']['input'];
};

export type CreateStockInput = {
  exchange: Exchange;
  lastNav: Scalars['Float']['input'];
  name: Scalars['String']['input'];
  symbol: Scalars['String']['input'];
};

export type DeleteFundInput = {
  fundId: Scalars['ID']['input'];
};

export type DeletePortfolioFundInput = {
  portfolioFundId: Scalars['ID']['input'];
};

export type DeletePortfolioInput = {
  portfolioId: Scalars['ID']['input'];
};

export type DeletePortfolioStockInput = {
  portfolioStockId: Scalars['ID']['input'];
};

export type DeleteStockInput = {
  stockId: Scalars['ID']['input'];
};

/**  Error codes  */
export enum ErrorCode {
  BAD_USER_INPUT = 'BAD_USER_INPUT',
  CONFLICT = 'CONFLICT',
  DATABASE_ERROR = 'DATABASE_ERROR',
  FORBIDDEN = 'FORBIDDEN',
  GRAPHQL_PARSE_FAILED = 'GRAPHQL_PARSE_FAILED',
  GRAPHQL_VALIDATION_FAILED = 'GRAPHQL_VALIDATION_FAILED',
  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',
  LOCKED = 'LOCKED',
  METHOD_NOT_ALLOWED = 'METHOD_NOT_ALLOWED',
  NOT_FOUND = 'NOT_FOUND',
  TOO_MANY_REQUESTS = 'TOO_MANY_REQUESTS',
  UNAUTHENTICATED = 'UNAUTHENTICATED'
}

export enum Exchange {
  BSE = 'BSE',
  LSE = 'LSE',
  NASDAQ = 'NASDAQ',
  NSE = 'NSE',
  NYSE = 'NYSE'
}

export type ForgotPasswordInput = {
  from__confirm?: InputMaybe<Scalars['String']['input']>;
  mobile: Scalars['PhoneNumber']['input'];
  name__confirm?: InputMaybe<Scalars['String']['input']>;
};

export type Fund = Node & {
  /**  Hybrid or Equity or Debt or FOF  */
  category?: Maybe<FundCategory>;
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  lastNav: Scalars['Float']['output'];
  name: Scalars['String']['output'];
  /**  Direct or Regular  */
  plan?: Maybe<FundPlan>;
  /**  Store google finance symbol  */
  symbol1?: Maybe<Scalars['String']['output']>;
  /**  Any other external symbol for future  */
  symbol2?: Maybe<Scalars['String']['output']>;
  /**  Growth or IDCW  */
  type?: Maybe<FundType>;
  updatedAt: Scalars['DateTime']['output'];
};

export enum FundCategory {
  CHILDRENS_FUND = 'CHILDRENS_FUND',
  DEBT_BANKING_AND_PSU = 'DEBT_BANKING_AND_PSU',
  DEBT_CORPORATE_BOND = 'DEBT_CORPORATE_BOND',
  DEBT_CREDIT_RISK = 'DEBT_CREDIT_RISK',
  DEBT_DYNAMIC_BOND = 'DEBT_DYNAMIC_BOND',
  DEBT_FLOATER = 'DEBT_FLOATER',
  DEBT_GILT = 'DEBT_GILT',
  DEBT_GILT_10_YEARS_CONSTANT = 'DEBT_GILT_10_YEARS_CONSTANT',
  DEBT_LIQUID = 'DEBT_LIQUID',
  DEBT_LONG_DURATION = 'DEBT_LONG_DURATION',
  DEBT_LOW_DURATION = 'DEBT_LOW_DURATION',
  DEBT_MEDIUM_DURATION = 'DEBT_MEDIUM_DURATION',
  DEBT_MEDIUM_TO_LONG_DURATION = 'DEBT_MEDIUM_TO_LONG_DURATION',
  DEBT_MONEY_MARKET = 'DEBT_MONEY_MARKET',
  DEBT_OVERNIGHT = 'DEBT_OVERNIGHT',
  DEBT_SHORT_DURATION = 'DEBT_SHORT_DURATION',
  DEBT_ULTRA_SHORT_DURATION = 'DEBT_ULTRA_SHORT_DURATION',
  EQUITY_BANKING_AND_FINANCIAL_SERVICES = 'EQUITY_BANKING_AND_FINANCIAL_SERVICES',
  EQUITY_DIVIDEND_YIELD = 'EQUITY_DIVIDEND_YIELD',
  EQUITY_ELSS = 'EQUITY_ELSS',
  EQUITY_FLEXI_CAP = 'EQUITY_FLEXI_CAP',
  EQUITY_FOCUSED = 'EQUITY_FOCUSED',
  EQUITY_LARGE_AND_MID_CAP = 'EQUITY_LARGE_AND_MID_CAP',
  EQUITY_LARGE_CAP = 'EQUITY_LARGE_CAP',
  EQUITY_MID_CAP = 'EQUITY_MID_CAP',
  EQUITY_MULTI_CAP = 'EQUITY_MULTI_CAP',
  EQUITY_SECTORAL_INFRASTRUCTURE = 'EQUITY_SECTORAL_INFRASTRUCTURE',
  EQUITY_SECTORAL_PHARMA_AND_HEALTHCARE = 'EQUITY_SECTORAL_PHARMA_AND_HEALTHCARE',
  EQUITY_SECTORAL_TECHNOLOGY = 'EQUITY_SECTORAL_TECHNOLOGY',
  EQUITY_SMALL_CAP = 'EQUITY_SMALL_CAP',
  EQUITY_THEMATIC_CONSUMPTION = 'EQUITY_THEMATIC_CONSUMPTION',
  EQUITY_THEMATIC_ESG = 'EQUITY_THEMATIC_ESG',
  EQUITY_THEMATIC_INTERNATIONAL = 'EQUITY_THEMATIC_INTERNATIONAL',
  EQUITY_THEMATIC_MANUFACTURING = 'EQUITY_THEMATIC_MANUFACTURING',
  EQUITY_THEMATIC_MNC = 'EQUITY_THEMATIC_MNC',
  EQUITY_THEMATIC_OTHERS = 'EQUITY_THEMATIC_OTHERS',
  EQUITY_THEMATIC_PSU = 'EQUITY_THEMATIC_PSU',
  EQUITY_THEMATIC_QUANTITATIVE = 'EQUITY_THEMATIC_QUANTITATIVE',
  EQUITY_THEMATIC_TRANSPORTATION = 'EQUITY_THEMATIC_TRANSPORTATION',
  EQUITY_VALUE = 'EQUITY_VALUE',
  ETF = 'ETF',
  FOF_DOMESTIC_DEBT = 'FOF_DOMESTIC_DEBT',
  FOF_DOMESTIC_EQUITY = 'FOF_DOMESTIC_EQUITY',
  FOF_DOMESTIC_GOLD = 'FOF_DOMESTIC_GOLD',
  FOF_DOMESTIC_HYBRID = 'FOF_DOMESTIC_HYBRID',
  FOF_DOMESTIC_SILVER = 'FOF_DOMESTIC_SILVER',
  FOF_OVERSEAS = 'FOF_OVERSEAS',
  HYBRID_AGGRESSIVE = 'HYBRID_AGGRESSIVE',
  HYBRID_ARBITRAGE = 'HYBRID_ARBITRAGE',
  HYBRID_CONSERVATIVE = 'HYBRID_CONSERVATIVE',
  HYBRID_DYNAMIC_ASSET_ALLOCATION = 'HYBRID_DYNAMIC_ASSET_ALLOCATION',
  HYBRID_EQUITY_SAVINGS = 'HYBRID_EQUITY_SAVINGS',
  HYBRID_MULTI_ASSET_ALLOCATION = 'HYBRID_MULTI_ASSET_ALLOCATION',
  INDEX_FUND = 'INDEX_FUND',
  RETIREMENT_FUND = 'RETIREMENT_FUND'
}

export enum FundPlan {
  Direct = 'Direct',
  Regular = 'Regular'
}

export enum FundType {
  BONUS = 'BONUS',
  GROWTH = 'GROWTH',
  IDCW = 'IDCW',
  IDCW_DAILY_PAYOUT = 'IDCW_DAILY_PAYOUT',
  IDCW_DAILY_REINVESTMENT = 'IDCW_DAILY_REINVESTMENT',
  IDCW_HALFYEARLY_PAYOUT = 'IDCW_HALFYEARLY_PAYOUT',
  IDCW_HALFYEARLY_REINVESTMENT = 'IDCW_HALFYEARLY_REINVESTMENT',
  IDCW_MONTHLY_PAYOUT = 'IDCW_MONTHLY_PAYOUT',
  IDCW_MONTHLY_REINVESTMENT = 'IDCW_MONTHLY_REINVESTMENT',
  IDCW_PAYOUT = 'IDCW_PAYOUT',
  IDCW_QUARTERLY_PAYOUT = 'IDCW_QUARTERLY_PAYOUT',
  IDCW_QUARTERLY_REINVESTMENT = 'IDCW_QUARTERLY_REINVESTMENT',
  IDCW_REINVESTMENT = 'IDCW_REINVESTMENT',
  IDCW_WEEKLY_PAYOUT = 'IDCW_WEEKLY_PAYOUT',
  IDCW_WEEKLY_REINVESTMENT = 'IDCW_WEEKLY_REINVESTMENT',
  IDCW_YEARLY_PAYOUT = 'IDCW_YEARLY_PAYOUT',
  IDCW_YEARLY_REINVESTMENT = 'IDCW_YEARLY_REINVESTMENT'
}

export type FundsInput = {
  category?: InputMaybe<FundCategory>;
  page?: InputMaybe<PageInput>;
  plan?: InputMaybe<FundPlan>;
  search?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<FundType>;
};

export type FundsPayload = PagePayload & {
  nodes: Array<Fund>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type Membership = Node & {
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  portfolio: Portfolio;
  role: UserRole;
  updatedAt: Scalars['DateTime']['output'];
  user: User;
};

export type Mutation = {
  createFund: Fund;
  createPortfolio: Portfolio;
  createPortfolioFund: PortfolioFund;
  createPortfolioStock: PortfolioStock;
  createStock: Stock;
  deleteFund: SuccessPayload;
  deletePortfolio: SuccessPayload;
  deletePortfolioFund: SuccessPayload;
  deletePortfolioStock: SuccessPayload;
  deleteStock: SuccessPayload;
  forgotPassword: SuccessPayload;
  resendCode: SuccessPayload;
  resetPassword: SuccessPayload;
  signIn: User;
  signUp: User;
  updateFund: Fund;
  updatePortfolio: Portfolio;
  updatePortfolioFund: PortfolioFund;
  updatePortfolioStock: PortfolioStock;
  updateStock: Stock;
  verifyCode: SuccessPayload;
};


export type MutationCreateFundArgs = {
  input: CreateFundInput;
};


export type MutationCreatePortfolioArgs = {
  input: CreatePortfolioInput;
};


export type MutationCreatePortfolioFundArgs = {
  input: CreatePortfolioFundInput;
};


export type MutationCreatePortfolioStockArgs = {
  input: CreatePortfolioStockInput;
};


export type MutationCreateStockArgs = {
  input: CreateStockInput;
};


export type MutationDeleteFundArgs = {
  input: DeleteFundInput;
};


export type MutationDeletePortfolioArgs = {
  input: DeletePortfolioInput;
};


export type MutationDeletePortfolioFundArgs = {
  input: DeletePortfolioFundInput;
};


export type MutationDeletePortfolioStockArgs = {
  input: DeletePortfolioStockInput;
};


export type MutationDeleteStockArgs = {
  input: DeleteStockInput;
};


export type MutationForgotPasswordArgs = {
  input: ForgotPasswordInput;
};


export type MutationResendCodeArgs = {
  input: ResendCodeInput;
};


export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};


export type MutationSignInArgs = {
  input: SignInInput;
};


export type MutationSignUpArgs = {
  input: SignUpInput;
};


export type MutationUpdateFundArgs = {
  input: UpdateFundInput;
};


export type MutationUpdatePortfolioArgs = {
  input: UpdatePortfolioInput;
};


export type MutationUpdatePortfolioFundArgs = {
  input: UpdatePortfolioFundInput;
};


export type MutationUpdatePortfolioStockArgs = {
  input: UpdatePortfolioStockInput;
};


export type MutationUpdateStockArgs = {
  input: UpdateStockInput;
};


export type MutationVerifyCodeArgs = {
  input: VerifyCodeInput;
};

export type Node = {
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type PageInfo = {
  endCursor?: Maybe<Scalars['String']['output']>;
  hasNextPage: Scalars['Boolean']['output'];
  hasPreviousPage: Scalars['Boolean']['output'];
  startCursor?: Maybe<Scalars['String']['output']>;
};

export type PageInput = {
  /**  Cursor-based pagination, load after this cursor  */
  after?: InputMaybe<Scalars['String']['input']>;
  /**  How many to load (from the start), supports 0 for getting the `total`  */
  first?: InputMaybe<Scalars['Int']['input']>;
  /**  How many to load (from the end, reversed results)  */
  last?: InputMaybe<Scalars['Int']['input']>;
  /**  Offset-based pagination, skip this many  */
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type PagePayload = {
  nodes: Array<Node>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type Portfolio = Node & {
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  funds: Array<PortfolioFund>;
  id: Scalars['ID']['output'];
  members: Array<Membership>;
  name: Scalars['String']['output'];
  stocks: Array<PortfolioStock>;
  updatedAt: Scalars['DateTime']['output'];
};

export type PortfolioFund = Node & {
  cost: Scalars['Float']['output'];
  createdAt: Scalars['DateTime']['output'];
  fund: Fund;
  id: Scalars['ID']['output'];
  portfolio: Portfolio;
  units: Scalars['Float']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type PortfolioFundsInput = {
  page?: InputMaybe<PageInput>;
  portfolioId: Scalars['ID']['input'];
};

export type PortfolioFundsPayload = PagePayload & {
  nodes: Array<PortfolioFund>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type PortfolioStock = Node & {
  cost: Scalars['Float']['output'];
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  portfolio: Portfolio;
  stock: Stock;
  units: Scalars['Float']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type PortfolioStocksInput = {
  page?: InputMaybe<PageInput>;
  portfolioId: Scalars['ID']['input'];
};

export type PortfolioStocksPayload = PagePayload & {
  nodes: Array<PortfolioStock>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type Query = {
  fund: Fund;
  funds: FundsPayload;
  me?: Maybe<User>;
  portfolio: Portfolio;
  portfolioFund: PortfolioFund;
  portfolioFunds: PortfolioFundsPayload;
  portfolioStock: PortfolioStock;
  portfolioStocks: PortfolioStocksPayload;
  stock: Stock;
  stocks: StocksPayload;
};


export type QueryFundArgs = {
  fundId: Scalars['ID']['input'];
};


export type QueryFundsArgs = {
  input?: InputMaybe<FundsInput>;
};


export type QueryPortfolioArgs = {
  portfolioId: Scalars['ID']['input'];
};


export type QueryPortfolioFundArgs = {
  portfolioFundId: Scalars['ID']['input'];
};


export type QueryPortfolioFundsArgs = {
  input: PortfolioFundsInput;
};


export type QueryPortfolioStockArgs = {
  portfolioStockId: Scalars['ID']['input'];
};


export type QueryPortfolioStocksArgs = {
  input: PortfolioStocksInput;
};


export type QueryStockArgs = {
  stockId: Scalars['ID']['input'];
};


export type QueryStocksArgs = {
  input?: InputMaybe<StocksInput>;
};

export type ResendCodeInput = {
  from__confirm?: InputMaybe<Scalars['String']['input']>;
  mobile?: InputMaybe<Scalars['PhoneNumber']['input']>;
  name__confirm?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type ResetPasswordInput = {
  code: Scalars['ID']['input'];
  from__confirm?: InputMaybe<Scalars['String']['input']>;
  mobile: Scalars['PhoneNumber']['input'];
  name__confirm?: InputMaybe<Scalars['String']['input']>;
  password: Scalars['ID']['input'];
};

export type SignInInput = {
  from__confirm?: InputMaybe<Scalars['String']['input']>;
  mobile: Scalars['PhoneNumber']['input'];
  name__confirm?: InputMaybe<Scalars['String']['input']>;
  password: Scalars['ID']['input'];
};

export type SignUpInput = {
  firstName: Scalars['ID']['input'];
  lastName?: InputMaybe<Scalars['ID']['input']>;
  mobile: Scalars['PhoneNumber']['input'];
  password: Scalars['ID']['input'];
};

export type Stock = Node & {
  createdAt: Scalars['DateTime']['output'];
  /**  Exchange + Symbol should be unique  */
  exchange: Exchange;
  id: Scalars['ID']['output'];
  lastPrice: Scalars['Float']['output'];
  name: Scalars['String']['output'];
  symbol: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type StocksInput = {
  exchange?: InputMaybe<Exchange>;
  page?: InputMaybe<PageInput>;
  search?: InputMaybe<Scalars['String']['input']>;
  symbol?: InputMaybe<Scalars['String']['input']>;
};

export type StocksPayload = PagePayload & {
  nodes: Array<Stock>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type SuccessPayload = {
  error?: Maybe<ErrorCode>;
};

export type UpdateFundInput = {
  category?: InputMaybe<FundCategory>;
  description?: InputMaybe<Scalars['String']['input']>;
  fundId: Scalars['ID']['input'];
  lastNav: Scalars['Float']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  plan?: InputMaybe<FundPlan>;
  symbol1?: InputMaybe<Scalars['String']['input']>;
  symbol2?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<FundType>;
};

export type UpdatePortfolioFundInput = {
  cost?: InputMaybe<Scalars['Float']['input']>;
  portfolioFundId: Scalars['ID']['input'];
  units?: InputMaybe<Scalars['Float']['input']>;
};

export type UpdatePortfolioInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  portfolioId: Scalars['ID']['input'];
};

export type UpdatePortfolioStockInput = {
  cost?: InputMaybe<Scalars['Float']['input']>;
  portfolioStockId: Scalars['ID']['input'];
  units?: InputMaybe<Scalars['Float']['input']>;
};

export type UpdateStockInput = {
  exchange?: InputMaybe<Exchange>;
  lastNav: Scalars['Float']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  stockId: Scalars['ID']['input'];
  symbol?: InputMaybe<Scalars['String']['input']>;
};

export type User = Node & {
  codes: Array<Code>;
  createdAt: Scalars['DateTime']['output'];
  firstName: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  isBlocked: Scalars['Boolean']['output'];
  isVerified: Scalars['Boolean']['output'];
  lastName?: Maybe<Scalars['ID']['output']>;
  memberships: Array<Membership>;
  mobile: Scalars['PhoneNumber']['output'];
  /**  The generated full (first+last) name  */
  name: Scalars['ID']['output'];
  password: Scalars['ID']['output'];
  salt: Scalars['ID']['output'];
  status: UserStatus;
  /**  A fresh JWT for the user  */
  token: Scalars['JWT']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export enum UserRole {
  Admin = 'Admin',
  Member = 'Member'
}

export enum UserStatus {
  Superadmin = 'Superadmin',
  User = 'User'
}

export type VerifyCodeInput = {
  code: Scalars['ID']['input'];
  from__confirm?: InputMaybe<Scalars['String']['input']>;
  mobile?: InputMaybe<Scalars['PhoneNumber']['input']>;
  name__confirm?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type FundResponseFragment = { id: string, name: string, description?: string | undefined, plan?: FundPlan | undefined, type?: FundType | undefined, category?: FundCategory | undefined, lastNav: number };

export type PageInfoResponseFragment = { hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | undefined, endCursor?: string | undefined };

export type PortfolioResponseFragment = { id: string, name: string, description?: string | undefined };

export type PortfolioFundResponseFragment = { id: string, units: number, cost: number, fund: { id: string, name: string, description?: string | undefined, plan?: FundPlan | undefined, type?: FundType | undefined, category?: FundCategory | undefined, lastNav: number } };

export type PortfolioStockResponseFragment = { id: string, units: number, cost: number, stock: { id: string, name: string, symbol: string, exchange: Exchange, lastPrice: number } };

export type StockResponseFragment = { id: string, name: string, symbol: string, exchange: Exchange, lastPrice: number };

export type MyUserResponseFragment = { id: string, firstName: string, lastName?: string | undefined, name: string, mobile: string, token: string, status: UserStatus, isVerified: boolean, isBlocked: boolean, memberships: Array<{ id: string, role: UserRole, portfolio: { id: string, name: string } }> };

export type GuestUserResponseFragment = { id: string };

export type SignInMutationVariables = Exact<{
  input: SignInInput;
}>;


export type SignInMutation = { signIn: { id: string, firstName: string, lastName?: string | undefined, name: string, mobile: string, token: string, status: UserStatus, isVerified: boolean, isBlocked: boolean, memberships: Array<{ id: string, role: UserRole, portfolio: { id: string, name: string } }> } };

export type SignUpMutationVariables = Exact<{
  input: SignUpInput;
}>;


export type SignUpMutation = { signUp: { id: string } };

export type VerifyCodeMutationVariables = Exact<{
  input: VerifyCodeInput;
}>;


export type VerifyCodeMutation = { verifyCode: { error?: ErrorCode | undefined } };

export type ResendCodeMutationVariables = Exact<{
  input: ResendCodeInput;
}>;


export type ResendCodeMutation = { resendCode: { error?: ErrorCode | undefined } };

export type ForgotPasswordMutationVariables = Exact<{
  input: ForgotPasswordInput;
}>;


export type ForgotPasswordMutation = { forgotPassword: { error?: ErrorCode | undefined } };

export type ResetPasswordMutationVariables = Exact<{
  input: ResetPasswordInput;
}>;


export type ResetPasswordMutation = { resetPassword: { error?: ErrorCode | undefined } };

export type CreatePortfolioMutationVariables = Exact<{
  input: CreatePortfolioInput;
}>;


export type CreatePortfolioMutation = { createPortfolio: { id: string } };

export type CreatePortfolioFundMutationVariables = Exact<{
  input: CreatePortfolioFundInput;
}>;


export type CreatePortfolioFundMutation = { createPortfolioFund: { id: string, units: number, cost: number, fund: { id: string, name: string, description?: string | undefined, plan?: FundPlan | undefined, type?: FundType | undefined, category?: FundCategory | undefined, lastNav: number } } };

export type CreatePortfolioStockMutationVariables = Exact<{
  input: CreatePortfolioStockInput;
}>;


export type CreatePortfolioStockMutation = { createPortfolioStock: { id: string, units: number, cost: number, stock: { id: string, name: string, symbol: string, exchange: Exchange, lastPrice: number } } };

export type MeQueryVariables = Exact<{ [key: string]: never; }>;


export type MeQuery = { me?: { id: string, firstName: string, lastName?: string | undefined, name: string, mobile: string, token: string, status: UserStatus, isVerified: boolean, isBlocked: boolean, memberships: Array<{ id: string, role: UserRole, portfolio: { id: string, name: string } }> } | undefined };

export type FundsQueryVariables = Exact<{
  input?: InputMaybe<FundsInput>;
}>;


export type FundsQuery = { funds: { nodes: Array<{ id: string, name: string, description?: string | undefined, plan?: FundPlan | undefined, type?: FundType | undefined, category?: FundCategory | undefined, lastNav: number }>, pageInfo: { hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | undefined, endCursor?: string | undefined } } };

export type PortfolioQueryVariables = Exact<{
  portfolioId: Scalars['ID']['input'];
}>;


export type PortfolioQuery = { portfolio: { id: string, name: string, description?: string | undefined } };

export type PortfolioFundsQueryVariables = Exact<{
  input: PortfolioFundsInput;
}>;


export type PortfolioFundsQuery = { portfolioFunds: { nodes: Array<{ id: string, units: number, cost: number, fund: { id: string, name: string, description?: string | undefined, plan?: FundPlan | undefined, type?: FundType | undefined, category?: FundCategory | undefined, lastNav: number } }>, pageInfo: { hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | undefined, endCursor?: string | undefined } } };

export type PortfolioStocksQueryVariables = Exact<{
  input: PortfolioStocksInput;
}>;


export type PortfolioStocksQuery = { portfolioStocks: { nodes: Array<{ id: string, units: number, cost: number, stock: { id: string, name: string, symbol: string, exchange: Exchange, lastPrice: number } }>, pageInfo: { hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | undefined, endCursor?: string | undefined } } };

export type StocksQueryVariables = Exact<{
  input?: InputMaybe<StocksInput>;
}>;


export type StocksQuery = { stocks: { nodes: Array<{ id: string, name: string, symbol: string, exchange: Exchange, lastPrice: number }>, pageInfo: { hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | undefined, endCursor?: string | undefined } } };


export const PageInfoResponseFragmentDoc = `
    fragment PageInfoResponse on PageInfo {
  hasNextPage
  hasPreviousPage
  startCursor
  endCursor
}
    `;
export const PortfolioResponseFragmentDoc = `
    fragment PortfolioResponse on Portfolio {
  id
  name
  description
}
    `;
export const FundResponseFragmentDoc = `
    fragment FundResponse on Fund {
  id
  name
  description
  plan
  type
  category
  lastNav
}
    `;
export const PortfolioFundResponseFragmentDoc = `
    fragment PortfolioFundResponse on PortfolioFund {
  id
  fund {
    ...FundResponse
  }
  units
  cost
}
    ${FundResponseFragmentDoc}`;
export const StockResponseFragmentDoc = `
    fragment StockResponse on Stock {
  id
  name
  symbol
  exchange
  lastPrice
}
    `;
export const PortfolioStockResponseFragmentDoc = `
    fragment PortfolioStockResponse on PortfolioStock {
  id
  stock {
    ...StockResponse
  }
  units
  cost
}
    ${StockResponseFragmentDoc}`;
export const MyUserResponseFragmentDoc = `
    fragment MyUserResponse on User {
  id
  firstName
  lastName
  name
  mobile
  token
  status
  isVerified
  isBlocked
  memberships {
    id
    role
    portfolio {
      id
      name
    }
  }
}
    `;
export const GuestUserResponseFragmentDoc = `
    fragment GuestUserResponse on User {
  id
}
    `;
export const SignInDocument = `
    mutation signIn($input: SignInInput!) {
  signIn(input: $input) {
    ...MyUserResponse
  }
}
    ${MyUserResponseFragmentDoc}`;

export const useSignInMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<SignInMutation, TError, SignInMutationVariables, TContext>) => {
    
    return useMutation<SignInMutation, TError, SignInMutationVariables, TContext>(
      {
    mutationKey: ['signIn'],
    mutationFn: (variables?: SignInMutationVariables) => reactQueryFetcher<SignInMutation, SignInMutationVariables>(SignInDocument, variables)(),
    ...options
  }
    )};

export const SignUpDocument = `
    mutation signUp($input: SignUpInput!) {
  signUp(input: $input) {
    ...GuestUserResponse
  }
}
    ${GuestUserResponseFragmentDoc}`;

export const useSignUpMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<SignUpMutation, TError, SignUpMutationVariables, TContext>) => {
    
    return useMutation<SignUpMutation, TError, SignUpMutationVariables, TContext>(
      {
    mutationKey: ['signUp'],
    mutationFn: (variables?: SignUpMutationVariables) => reactQueryFetcher<SignUpMutation, SignUpMutationVariables>(SignUpDocument, variables)(),
    ...options
  }
    )};

export const VerifyCodeDocument = `
    mutation verifyCode($input: VerifyCodeInput!) {
  verifyCode(input: $input) {
    error
  }
}
    `;

export const useVerifyCodeMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<VerifyCodeMutation, TError, VerifyCodeMutationVariables, TContext>) => {
    
    return useMutation<VerifyCodeMutation, TError, VerifyCodeMutationVariables, TContext>(
      {
    mutationKey: ['verifyCode'],
    mutationFn: (variables?: VerifyCodeMutationVariables) => reactQueryFetcher<VerifyCodeMutation, VerifyCodeMutationVariables>(VerifyCodeDocument, variables)(),
    ...options
  }
    )};

export const ResendCodeDocument = `
    mutation resendCode($input: ResendCodeInput!) {
  resendCode(input: $input) {
    error
  }
}
    `;

export const useResendCodeMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<ResendCodeMutation, TError, ResendCodeMutationVariables, TContext>) => {
    
    return useMutation<ResendCodeMutation, TError, ResendCodeMutationVariables, TContext>(
      {
    mutationKey: ['resendCode'],
    mutationFn: (variables?: ResendCodeMutationVariables) => reactQueryFetcher<ResendCodeMutation, ResendCodeMutationVariables>(ResendCodeDocument, variables)(),
    ...options
  }
    )};

export const ForgotPasswordDocument = `
    mutation forgotPassword($input: ForgotPasswordInput!) {
  forgotPassword(input: $input) {
    error
  }
}
    `;

export const useForgotPasswordMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<ForgotPasswordMutation, TError, ForgotPasswordMutationVariables, TContext>) => {
    
    return useMutation<ForgotPasswordMutation, TError, ForgotPasswordMutationVariables, TContext>(
      {
    mutationKey: ['forgotPassword'],
    mutationFn: (variables?: ForgotPasswordMutationVariables) => reactQueryFetcher<ForgotPasswordMutation, ForgotPasswordMutationVariables>(ForgotPasswordDocument, variables)(),
    ...options
  }
    )};

export const ResetPasswordDocument = `
    mutation resetPassword($input: ResetPasswordInput!) {
  resetPassword(input: $input) {
    error
  }
}
    `;

export const useResetPasswordMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<ResetPasswordMutation, TError, ResetPasswordMutationVariables, TContext>) => {
    
    return useMutation<ResetPasswordMutation, TError, ResetPasswordMutationVariables, TContext>(
      {
    mutationKey: ['resetPassword'],
    mutationFn: (variables?: ResetPasswordMutationVariables) => reactQueryFetcher<ResetPasswordMutation, ResetPasswordMutationVariables>(ResetPasswordDocument, variables)(),
    ...options
  }
    )};

export const CreatePortfolioDocument = `
    mutation createPortfolio($input: CreatePortfolioInput!) {
  createPortfolio(input: $input) {
    id
  }
}
    `;

export const useCreatePortfolioMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreatePortfolioMutation, TError, CreatePortfolioMutationVariables, TContext>) => {
    
    return useMutation<CreatePortfolioMutation, TError, CreatePortfolioMutationVariables, TContext>(
      {
    mutationKey: ['createPortfolio'],
    mutationFn: (variables?: CreatePortfolioMutationVariables) => reactQueryFetcher<CreatePortfolioMutation, CreatePortfolioMutationVariables>(CreatePortfolioDocument, variables)(),
    ...options
  }
    )};

export const CreatePortfolioFundDocument = `
    mutation createPortfolioFund($input: CreatePortfolioFundInput!) {
  createPortfolioFund(input: $input) {
    ...PortfolioFundResponse
  }
}
    ${PortfolioFundResponseFragmentDoc}`;

export const useCreatePortfolioFundMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreatePortfolioFundMutation, TError, CreatePortfolioFundMutationVariables, TContext>) => {
    
    return useMutation<CreatePortfolioFundMutation, TError, CreatePortfolioFundMutationVariables, TContext>(
      {
    mutationKey: ['createPortfolioFund'],
    mutationFn: (variables?: CreatePortfolioFundMutationVariables) => reactQueryFetcher<CreatePortfolioFundMutation, CreatePortfolioFundMutationVariables>(CreatePortfolioFundDocument, variables)(),
    ...options
  }
    )};

export const CreatePortfolioStockDocument = `
    mutation createPortfolioStock($input: CreatePortfolioStockInput!) {
  createPortfolioStock(input: $input) {
    ...PortfolioStockResponse
  }
}
    ${PortfolioStockResponseFragmentDoc}`;

export const useCreatePortfolioStockMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreatePortfolioStockMutation, TError, CreatePortfolioStockMutationVariables, TContext>) => {
    
    return useMutation<CreatePortfolioStockMutation, TError, CreatePortfolioStockMutationVariables, TContext>(
      {
    mutationKey: ['createPortfolioStock'],
    mutationFn: (variables?: CreatePortfolioStockMutationVariables) => reactQueryFetcher<CreatePortfolioStockMutation, CreatePortfolioStockMutationVariables>(CreatePortfolioStockDocument, variables)(),
    ...options
  }
    )};

export const MeDocument = `
    query me {
  me {
    ...MyUserResponse
  }
}
    ${MyUserResponseFragmentDoc}`;

export const useMeQuery = <
      TData = MeQuery,
      TError = unknown
    >(
      variables?: MeQueryVariables,
      options?: Omit<UseQueryOptions<MeQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<MeQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<MeQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['me'] : ['me', variables],
    queryFn: reactQueryFetcher<MeQuery, MeQueryVariables>(MeDocument, variables),
    ...options
  }
    )};

export const FundsDocument = `
    query funds($input: FundsInput) {
  funds(input: $input) {
    nodes {
      ...FundResponse
    }
    pageInfo {
      ...PageInfoResponse
    }
  }
}
    ${FundResponseFragmentDoc}
${PageInfoResponseFragmentDoc}`;

export const useFundsQuery = <
      TData = FundsQuery,
      TError = unknown
    >(
      variables?: FundsQueryVariables,
      options?: Omit<UseQueryOptions<FundsQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<FundsQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<FundsQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['funds'] : ['funds', variables],
    queryFn: reactQueryFetcher<FundsQuery, FundsQueryVariables>(FundsDocument, variables),
    ...options
  }
    )};

export const PortfolioDocument = `
    query portfolio($portfolioId: ID!) {
  portfolio(portfolioId: $portfolioId) {
    ...PortfolioResponse
  }
}
    ${PortfolioResponseFragmentDoc}`;

export const usePortfolioQuery = <
      TData = PortfolioQuery,
      TError = unknown
    >(
      variables: PortfolioQueryVariables,
      options?: Omit<UseQueryOptions<PortfolioQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<PortfolioQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<PortfolioQuery, TError, TData>(
      {
    queryKey: ['portfolio', variables],
    queryFn: reactQueryFetcher<PortfolioQuery, PortfolioQueryVariables>(PortfolioDocument, variables),
    ...options
  }
    )};

export const PortfolioFundsDocument = `
    query portfolioFunds($input: PortfolioFundsInput!) {
  portfolioFunds(input: $input) {
    nodes {
      ...PortfolioFundResponse
    }
    pageInfo {
      ...PageInfoResponse
    }
  }
}
    ${PortfolioFundResponseFragmentDoc}
${PageInfoResponseFragmentDoc}`;

export const usePortfolioFundsQuery = <
      TData = PortfolioFundsQuery,
      TError = unknown
    >(
      variables: PortfolioFundsQueryVariables,
      options?: Omit<UseQueryOptions<PortfolioFundsQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<PortfolioFundsQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<PortfolioFundsQuery, TError, TData>(
      {
    queryKey: ['portfolioFunds', variables],
    queryFn: reactQueryFetcher<PortfolioFundsQuery, PortfolioFundsQueryVariables>(PortfolioFundsDocument, variables),
    ...options
  }
    )};

export const PortfolioStocksDocument = `
    query portfolioStocks($input: PortfolioStocksInput!) {
  portfolioStocks(input: $input) {
    nodes {
      ...PortfolioStockResponse
    }
    pageInfo {
      ...PageInfoResponse
    }
  }
}
    ${PortfolioStockResponseFragmentDoc}
${PageInfoResponseFragmentDoc}`;

export const usePortfolioStocksQuery = <
      TData = PortfolioStocksQuery,
      TError = unknown
    >(
      variables: PortfolioStocksQueryVariables,
      options?: Omit<UseQueryOptions<PortfolioStocksQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<PortfolioStocksQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<PortfolioStocksQuery, TError, TData>(
      {
    queryKey: ['portfolioStocks', variables],
    queryFn: reactQueryFetcher<PortfolioStocksQuery, PortfolioStocksQueryVariables>(PortfolioStocksDocument, variables),
    ...options
  }
    )};

export const StocksDocument = `
    query stocks($input: StocksInput) {
  stocks(input: $input) {
    nodes {
      ...StockResponse
    }
    pageInfo {
      ...PageInfoResponse
    }
  }
}
    ${StockResponseFragmentDoc}
${PageInfoResponseFragmentDoc}`;

export const useStocksQuery = <
      TData = StocksQuery,
      TError = unknown
    >(
      variables?: StocksQueryVariables,
      options?: Omit<UseQueryOptions<StocksQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<StocksQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<StocksQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['stocks'] : ['stocks', variables],
    queryFn: reactQueryFetcher<StocksQuery, StocksQueryVariables>(StocksDocument, variables),
    ...options
  }
    )};
